#pragma kernel CSMain
#pragma multi_compile __ BUILD_LINES

#define EPSILON 1e-8
#define SHARED_MEMORY_SIZE 256
#define THREAD_COUNT 64
#define THREAD_DIM uint3(64, 4, 1)
#define GROUP_DIM uint3(_InstanceCount / 64, 1, 1)

float4x4 _VPMatrix;
uint _InstanceCount;
uint _ActorCount;

float _DistanceSoftening;
float _DistanceCoeff;
float _TrailLength;
float _TimeStep;
float _MaxMass;
float _G;

struct Input
{
    uint3 GroupID : SV_GroupID;
    uint3 ThreadID : SV_GroupThreadID;
};

struct GeometryData
{
#if defined(BUILD_LINES)
    float3 Vertices[2];
#else
    float3 Vertices[1];
#endif

    float3 Colour;
};

struct ParticleData
{
    float3 Position;
    float3 Velocity;
    float Mass;
    float Entropy;
};

struct ActorData
{
    float3 Position;
    float3 Force;
    float Mass;
};

struct DrawCallArgs
{
    uint VerticesPerInstance;
    uint InstanceCount;
    uint StartVertexLocation;
    uint StartInstanceLocation;
};

StructuredBuffer<ParticleData> _ParticleBufferRead;
StructuredBuffer<ActorData> _ActorBuffer;

RWStructuredBuffer<ParticleData> _ParticleBufferWrite;
RWStructuredBuffer<DrawCallArgs> _DrawCallArgsBuffer;
AppendStructuredBuffer<GeometryData> _GeometryBuffer;

groupshared ParticleData _SharedData[SHARED_MEMORY_SIZE];

#include "ComputeHelperFunctions.hlsl"

void BuildGeometry(ParticleData data)
{
    // Avoid sending particles to vertex shader if they are outside camera frustrum
    if (ShouldClip(data))
        return;

    GeometryData geo;

    geo.Colour = Colourise(data) * CalcLuminosity(data.Mass);
    geo.Vertices[0] = data.Position;

#if defined(BUILD_LINES)
    geo.Vertices[1] = data.Position - (data.Velocity * _TrailLength);
#endif

    _GeometryBuffer.Append(geo);
    InterlockedAdd(_DrawCallArgsBuffer[0].InstanceCount, 1);
}

void ApplyForces(Input input, ParticleData data, uint idx)
{
    CalcForces(input, /*inout*/ data);
    _ParticleBufferWrite[idx] = data;
}

[numthreads(THREAD_COUNT, 1, 1)]
void CSMain (Input input)
{
    uint idx = input.GroupID.x * THREAD_COUNT + input.ThreadID.x;
    ParticleData data = _ParticleBufferRead[idx];

    ApplyForces(input, data, idx);
    BuildGeometry(data);
}