#pragma kernel CSMain
#pragma multi_compile __ BUILD_LINES

#define EPSILON 1e-8
#define SHARED_MEMORY_SIZE 256
#define THREAD_COUNT 64
#define THREAD_DIM uint3(64, 4, 1)
#define GROUP_DIM uint3(_InstanceCount / 64, 1, 1)

float4x4 _VPMatrix;
uint _InstanceCount;

float _DistanceSoftening;
float _DistanceCoeff;
float _TrailLength;
float _TimeStep;
float _MaxMass;
float _G;

struct Input
{
    uint3 GroupID : SV_GroupID;
    uint3 ThreadID : SV_GroupThreadID;
};

struct GeometryData
{
#if defined(BUILD_LINES)
    float3 Vertices[2];
#else
    float3 Vertices[1];
#endif

    float3 Colour;
};

struct ParticleData
{
    float3 Position;
    float3 Velocity;
    float Mass;
    float Entropy;
};

struct DrawCallArgs
{
    uint VerticesPerInstance;
    uint InstanceCount;
    uint StartVertexLocation;
    uint StartInstanceLocation;
};

StructuredBuffer<ParticleData> _ParticleBufferRead;

RWStructuredBuffer<ParticleData> _ParticleBufferWrite;
RWStructuredBuffer<DrawCallArgs> _DrawCallArgsBuffer;
AppendStructuredBuffer<GeometryData> _GeometryBuffer;

groupshared ParticleData _SharedData[SHARED_MEMORY_SIZE];

float3 SafeNormalise(float3 vec, float len)
{
    // The intrinsic normalize() function seems to return NaN's
    return vec / max(len, EPSILON);
}

void CalcGravitation(ParticleData data, ParticleData dataOther, inout float3 force)
{
    float m1m2 = data.Mass * dataOther.Mass;

    float3 toOther = dataOther.Position - data.Position;
    float r = length(toOther);

    // Direction of gravitation force
    toOther = SafeNormalise(toOther, r);

    // Inverse square law
    r *= _DistanceCoeff;
    float r2 = max(r * r, EPSILON);
    r2 = lerp(r2, 1.0, _DistanceSoftening);

    // Newton's law of universal gravitation
    // F = G(m1m2/r^2)
    force += toOther * _G * (m1m2 / r2);
}

void CalcForces(Input input, inout ParticleData data)
{
    #define N _InstanceCount / THREAD_DIM.y

    uint start = N * input.ThreadID.y;
    uint finish = start + N;
    uint tile = start / N;

    uint x;
    uint idxRead;
    uint idxShared;

    float3 force = float3(0.0, 0.0, 0.0);

    //[unroll(N / THREAD_DIM.x)]
    for (uint i = start; i < finish; i += THREAD_DIM.x, tile++) 
    {
        x = input.GroupID.x + tile;

        idxShared = input.ThreadID.x + THREAD_DIM.x * input.ThreadID.y;
        idxRead = ((x) < GROUP_DIM.x) ? (x) : (x - GROUP_DIM.x)  * THREAD_DIM.x + input.ThreadID.x;

        _SharedData[idxShared] = _ParticleBufferRead[idxRead];
        GroupMemoryBarrierWithGroupSync();

        [unroll(THREAD_DIM.x)]
        for (uint j = 0; j < THREAD_DIM.x; j++) 
        {
            idxShared = j + THREAD_DIM.x * input.ThreadID.y;
            CalcGravitation(data, _SharedData[idxShared], /*inout*/ force);
        }

        GroupMemoryBarrierWithGroupSync();
    }

    float3 acceleration = (force / data.Mass) * _TimeStep;

    data.Velocity += acceleration;
    data.Position += data.Velocity;
}

float CalcLuminosity(float mass)
{
    // Massâ€“luminosity relation
    // L = m^3.5

    #define LUM_EXPONENT 1.2
    #define LUM_DIM 0.1

    float lum = saturate(mass / _MaxMass);

    lum = pow(lum, LUM_EXPONENT);
    lum = max(lum, LUM_DIM);

    return lum;
}

float3 Colourise(ParticleData data)
{
    #define COLOUR_A float3(0.176, 0.733, 0.921)
    #define COLOUR_B float3(1.2, 0.6, 0.1)

    float3 base = lerp(COLOUR_A, COLOUR_B, data.Entropy);
    return base;
}

float2 ScreenPosition(float4 position)
{
    float4 o = position * 0.5f;

    o.xy = float2(o.x, o.y) + o.w;
    o.zw = position.zw;
    o.xy /= o.w;

    return o.xy;
}

bool ShouldClip(ParticleData data)
{
    float4 position = float4(data.Position, 1.0);
    position = mul(_VPMatrix, position);

    float2 screenUV = ScreenPosition(position);
    return screenUV.x < 0.0 || screenUV.x > 1.0 || screenUV.y < 0.0 || screenUV.y > 1.0;
}

void BuildGeometry(ParticleData data)
{
    // Avoid sending particles to vertex shader if they are outside camera frustrum
    if (ShouldClip(data))
        return;

    GeometryData geo;

    geo.Colour = Colourise(data) * CalcLuminosity(data.Mass);
    geo.Vertices[0] = data.Position;

#if defined(BUILD_LINES)
    geo.Vertices[1] = data.Position - (data.Velocity * _TrailLength);
#endif

    _GeometryBuffer.Append(geo);
    InterlockedAdd(_DrawCallArgsBuffer[0].InstanceCount, 1);
}

void ApplyForces(Input input, ParticleData data, uint idx)
{
    CalcForces(input, /*inout*/ data);
    _ParticleBufferWrite[idx] = data;
}

[numthreads(THREAD_COUNT, 1, 1)]
void CSMain (Input input)
{
    uint idx = input.GroupID.x * THREAD_COUNT + input.ThreadID.x;
    ParticleData data = _ParticleBufferRead[idx];

    ApplyForces(input, data, idx);
    BuildGeometry(data);
}